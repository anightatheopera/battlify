<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vote - Lorian Awards</title>
    <link rel="stylesheet" href="/static/styles.css?v=21">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>
    <header class="header">
        <div style="display:flex; align-items:center; gap:10px;">
            <a href="/">
                <img src="/static/logo.png" alt="Logo" class="site-logo">
            </a>
            <a href="/" class="site-title">LORIAN AWARDS</a>
        </div>
    </header>

    <div class="container"> 
        <div class="controls-header">
            <h1 id="tournament-title" style="margin:0;">Loading...</h1>
            <div class="controls-actions">
                <button onclick="downloadBracketImage()" class="download-btn">
                    üì∏ Save
                </button>
                <a id="manage-link" href="#" style="font-size:0.9em; color: #888; display: none;">[Manage]</a>
            </div>
        </div>

        <div id="round-info" class="round-info" style="display:none;">
            <h2 id="current-round-name"></h2>
            <div id="timer" class="timer"></div>
        </div>

        <div class="zoom-controls">
            <button class="zoom-btn" onclick="adjustZoom(-0.1)">‚ûñ</button>
            <button class="zoom-btn" onclick="resetZoom()">‚Ü∫</button>
            <button class="zoom-btn" onclick="adjustZoom(0.1)">‚ûï</button>
        </div>

        <div class="bracket-window" id="bracket-window">
            <div id="bracket-capture-area" class="bracket-wrapper">
                <div id="bracket-left" class="bracket-half left"></div>
                <div id="bracket-final" class="bracket-final"></div>
                <div id="bracket-right" class="bracket-half right"></div>
            </div>
        </div>

        <div id="error-msg" style="color: red; text-align:center; margin-top:20px;"></div>
    </div>

    <script src="/static/script.js"></script>
    <script>
        // ==========================================
        // 1. DRAG TO SCROLL LOGIC (Touch & Mouse)
        // ==========================================
        const slider = document.getElementById('bracket-window');
        let isDown = false;
        let startX, startY;
        let scrollLeft, scrollTop;

        // --- MOUSE EVENTS ---
        slider.addEventListener('mousedown', (e) => {
            isDown = true;
            slider.style.cursor = 'grabbing';
            startX = e.pageX - slider.offsetLeft;
            startY = e.pageY - slider.offsetTop;
            scrollLeft = slider.scrollLeft;
            scrollTop = slider.scrollTop;
        });

        slider.addEventListener('mouseleave', () => {
            isDown = false;
            slider.style.cursor = 'grab';
        });

        slider.addEventListener('mouseup', () => {
            isDown = false;
            slider.style.cursor = 'grab';
        });

        slider.addEventListener('mousemove', (e) => {
            if (!isDown) return;
            e.preventDefault();
            const x = e.pageX - slider.offsetLeft;
            const y = e.pageY - slider.offsetTop;
            const walkX = (x - startX); 
            const walkY = (y - startY);
            slider.scrollLeft = scrollLeft - walkX;
            slider.scrollTop = scrollTop - walkY;
        });

        // --- TOUCH EVENTS (For Mobile Fingers) ---
        slider.addEventListener('touchstart', (e) => {
            isDown = true;
            startX = e.touches[0].pageX - slider.offsetLeft;
            startY = e.touches[0].pageY - slider.offsetTop;
            scrollLeft = slider.scrollLeft;
            scrollTop = slider.scrollTop;
        });

        slider.addEventListener('touchend', () => {
            isDown = false;
        });

        slider.addEventListener('touchmove', (e) => {
            if (!isDown) return;
            // Don't prevent default if we are mostly scrolling vertically on mobile body
            // e.preventDefault(); 
            const x = e.touches[0].pageX - slider.offsetLeft;
            const y = e.touches[0].pageY - slider.offsetTop;
            const walkX = (x - startX); 
            const walkY = (y - startY);
            slider.scrollLeft = scrollLeft - walkX;
            slider.scrollTop = scrollTop - walkY;
        });

        // ==========================================
        // 2. ZOOM LOGIC
        // ==========================================
        let currentZoom = 1.0;

        function adjustZoom(delta) {
            currentZoom += delta;
            if (currentZoom < 0.2) currentZoom = 0.2;
            if (currentZoom > 3.0) currentZoom = 3.0; // Allow deeper zoom
            applyZoom();
        }

        function resetZoom() {
            currentZoom = 1.0;
            applyZoom();
            // Reset scroll to center-ish
            slider.scrollLeft = (slider.scrollWidth - slider.clientWidth) / 2;
        }

        function applyZoom() {
            const wrapper = document.getElementById('bracket-capture-area');
            wrapper.style.transform = `scale(${currentZoom})`;
            
            // IMPORTANT: Update width/height to force scrollbars to appear
            // This is what allows you to scroll to the edges when zoomed in
            if(currentZoom > 1) {
                // wrapper.style.width = `${currentZoom * 100}%`; 
                // We rely on the native scale size pushing the margins
            } else {
                // If zoomed out, ensure it doesn't align weirdly
                // wrapper.style.width = 'auto';
            }
        }

        // ==========================================
        // 3. DOWNLOAD LOGIC
        // ==========================================
        function downloadBracketImage() {
            const element = document.getElementById("bracket-capture-area");
            const btn = document.querySelector(".download-btn");
            const originalText = btn.innerText;

            btn.innerText = "Generating...";
            btn.style.opacity = "0.7";

            // Snapshot state
            const prevTransform = element.style.transform;
            element.style.transform = "scale(1)"; // Reset for clean shot

            html2canvas(element, {
                backgroundColor: "#050505",
                useCORS: true,
                scale: 2,
                scrollX: 0,
                scrollY: 0,
                windowWidth: element.scrollWidth,
                windowHeight: element.scrollHeight
            }).then(canvas => {
                const link = document.createElement('a');
                link.download = `bracket_${Date.now()}.png`;
                link.href = canvas.toDataURL("image/png");
                link.click();
                
                element.style.transform = prevTransform;
                btn.innerText = originalText;
                btn.style.opacity = "1";
            }).catch(err => {
                console.error(err);
                alert("Image generation failed.");
                element.style.transform = prevTransform;
                btn.innerText = originalText;
                btn.style.opacity = "1";
            });
        }

        // ==========================================
        // 4. DATA LOADING
        // ==========================================
        const tournamentId = getTournamentIdFromUrl();
        
        if (isLoggedIn()) {
            const manageLink = document.getElementById('manage-link');
            manageLink.href = `/manage/${tournamentId}`;
            manageLink.style.display = 'inline';
        }

        fetch(`/api/vote/tournament/${tournamentId}`)
            .then(res => {
                if (!res.ok) throw new Error("Tournament not found.");
                return res.json();
            })
            .then(data => {
                document.getElementById('tournament-title').innerText = data.name;
                
                adjustBracketScale(data.rounds.length);

                if (data.status === 'active') {
                    const currentRound = data.rounds[data.current_round_index];
                    document.getElementById('current-round-name').innerText = "VOTING ACTIVE: " + currentRound.round_name;
                    document.getElementById('round-info').style.display = 'block';
                    startTimer(currentRound.end_time);
                } else if (data.status === 'completed') {
                    document.getElementById('current-round-name').innerText = "TOURNAMENT COMPLETED";
                    document.getElementById('round-info').style.display = 'block';
                    const timerEl = document.getElementById('timer');
                    timerEl.innerText = "Winner!: Check the final bracket!";
                    timerEl.style.color = "var(--accent-color)";
                }

                renderTreeBracket(data);
                
                // Initial Scroll Center
                setTimeout(() => {
                   const scrollX = (slider.scrollWidth - slider.clientWidth) / 2;
                   slider.scrollLeft = scrollX;
                }, 100);
            })
            .catch(err => {
                document.getElementById('error-msg').innerText = err.message;
            });

        function adjustBracketScale(totalRounds) {
            const root = document.documentElement;
            const isMobile = window.innerWidth < 768;

            if (totalRounds <= 3) {
                root.style.setProperty('--column-width', isMobile ? '200px' : '280px');
                root.style.setProperty('--match-gap', '40px');
            } 
            else if (totalRounds <= 5) {
                root.style.setProperty('--column-width', isMobile ? '180px' : '260px');
                root.style.setProperty('--match-gap', '30px');
            } 
            else {
                root.style.setProperty('--column-width', isMobile ? '160px' : '240px');
                root.style.setProperty('--match-gap', '20px');
            }
        }

        function renderTreeBracket(data) {
            const leftRoot = document.getElementById('bracket-left');
            const rightRoot = document.getElementById('bracket-right');
            const finalRoot = document.getElementById('bracket-final');

            leftRoot.innerHTML = ''; rightRoot.innerHTML = ''; finalRoot.innerHTML = '';

            data.rounds.forEach((round, index) => {
                const isVotingRound = (index === data.current_round_index && data.status === 'active');
                
                if (round.matches.length === 1) {
                    const col = createColumn();
                    col.appendChild(createMatchNode(round.matches[0], isVotingRound, index));
                    finalRoot.appendChild(col);
                    return;
                } 

                const leftCol = createColumn();
                const rightCol = createColumn();
                
                const matches = round.matches;
                const midPoint = Math.ceil(matches.length / 2);
                const leftMatches = matches.slice(0, midPoint);
                const rightMatches = matches.slice(midPoint);

                appendMatchesAsPairs(leftCol, leftMatches, isVotingRound, index, 'left');
                appendMatchesAsPairs(rightCol, rightMatches, isVotingRound, index, 'right');

                leftRoot.appendChild(leftCol);
                rightRoot.appendChild(rightCol);
            });
        }

        function appendMatchesAsPairs(column, matches, isVotingRound, roundIndex, side) {
            for (let i = 0; i < matches.length; i += 2) {
                if (i + 1 < matches.length) {
                    const wrapper = document.createElement('div');
                    wrapper.className = `match-pair ${side}`;
                    wrapper.appendChild(createMatchNode(matches[i], isVotingRound, roundIndex));
                    wrapper.appendChild(createMatchNode(matches[i+1], isVotingRound, roundIndex));
                    column.appendChild(wrapper);
                } else {
                    column.appendChild(createMatchNode(matches[i], isVotingRound, roundIndex));
                }
            }
        }

        function createColumn() {
            const col = document.createElement('div');
            col.className = 'round-column';
            return col;
        }

        function createMatchNode(match, isVotingRound, roundIndex) {
            const node = document.createElement('div');
            node.className = 'bracket-match';
            node.appendChild(createTeamRow(match.contestant_a, match.votes_a, match, 'a', isVotingRound, roundIndex));
            if (match.contestant_b) {
                node.appendChild(createTeamRow(match.contestant_b, match.votes_b, match, 'b', isVotingRound, roundIndex));
            } else {
                const bye = document.createElement('div');
                bye.className = 'bracket-team lost';
                bye.style.justifyContent = 'center';
                bye.innerHTML = '<span style="font-size:0.8em; color:#555;">lucky song! going to the next round with no competition ;)</span>';
                node.appendChild(bye);
            }
            return node;
        }

        function createTeamRow(contestant, votes, match, option, isVotingRound, roundIndex) {
            const row = document.createElement('div');
            let statusClass = '';
            if (match.winner_id === contestant.id) statusClass = 'winner';
            else if (match.winner_id && match.winner_id !== contestant.id) statusClass = 'lost';
            
            row.className = `bracket-team ${statusClass}`;

            const img = document.createElement('img');
            img.src = contestant.image_url || '/static/logo.png';
            img.className = 'team-art';
            img.crossOrigin = "anonymous"; 
            
            const nameDiv = document.createElement('div');
            nameDiv.className = 'team-name';
            nameDiv.innerText = contestant.title;

            const badge = document.createElement('div');
            badge.className = 'vote-badge';
            badge.innerText = votes;

            row.appendChild(img);
            row.appendChild(nameDiv);
            row.appendChild(badge);

            const storageKey = `voted_${tournamentId}_r${roundIndex}_m${match.match_id}`;
            const hasVoted = localStorage.getItem(storageKey);

            if (isVotingRound && !match.winner_id) {
                if (hasVoted) {
                    row.onclick = () => alert("‚ö†Ô∏è You have already voted.");
                    row.style.cursor = "not-allowed";
                    row.style.opacity = "0.7"; 
                } else {
                    row.onclick = function() {
                        if(confirm(`Vote for ${contestant.title}?`)) {
                            badge.innerText = parseInt(votes) + 1;
                            badge.style.color = "var(--accent-color)";
                            row.style.background = "#333";
                            vote(match.match_id, option, row);
                            localStorage.setItem(storageKey, "true");
                            row.onclick = () => alert("‚ö†Ô∏è You have already voted.");
                            row.style.cursor = "not-allowed";
                        }
                    };
                }
            } else {
                row.style.cursor = "default";
            }
            return row;
        }
    </script>
</body>
</html>